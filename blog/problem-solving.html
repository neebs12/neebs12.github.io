<!DOCTYPE html>
<html>
  <head>
    <title>Problem Solving</title>
    <meta charset="UTF-8">
    <link href="../styles/main.css" rel="stylesheet" type="text/css">
  </head>
  
  <body>
    <main>
      <img src="/images/problem-solving-banner.png" alt="Banner" id="banner">
      <h1>Problem Solving</h1>
      <h2>The Problem: Nested Data Structures!</h2>
      <p>
        The <code>whereAreYou</code> problem was quite interesting. Its difficulty essentially lies in not knowing what object the parameter <code>arr</code> is passed with. 
      </p>
      <p>
        How would we know how to return the correct values if we didn&#39;t know what we are given to begin with? If I was a total beginner, I wouldn&#39;t know where to start! The problem description certainly does not reveal to me what my function is supposed to get!
      </p>
      <p>
        I think the key here is to use the power of <code>console.log</code>. This method essentially logs to the console whatever argument you pass it in. Logging the parameter <code>arr</code> reveals a nested data structure that is an array of objects! 
      </p>
      <pre><code class="lang-javascript">
  console.log(<span class="hljs-literal">arr</span>)
  <span class="hljs-meta">/*
  [
    {...},
    {...},
    {...}
  ]
  */</span>
      </code></pre>
      <p>
        Finally! We can see the structure of our input is. We get to know some crucial information here: the top level data structure is an array, and each elements are generic JavaScript objects with still unknown properties and property values. 
      </p>
      <p>
        So what is the next step? <em>We keep logging!</em>
      </p>

      <h3>Unwrapping the Array</h3>
      <p>
        Of course, one piece of the puzzle has been exposed, but it yet reveals more pieces! How do we explore the nested objects? We can iterate over the array <code>arr</code> and log each iteration! One way to do this is via <code>.forEach</code> method.
      </p>
      <pre><code class="lang-javascript">
  arr.forEach(<span class="hljs-literal">element</span> =&gt; console.log(<span class="hljs-literal">element</span>))
  <span class="hljs-meta">// -&gt; { door: 1, hiding: 'Shaggy' }
  // -&gt; { door: 2, hiding: 'Scooby' }
  // -&gt; { door: 3, hiding: 'Velma' } </span>
      </code></pre>
      
      <h3>Accessing sub-object properties</h3>
      <p>
        NOW we have revealed what the nested data structure was hiding from us! Now we can complete the total problem! Within the <code>forEach</code> callback, we know that each <code>element</code> is an sub-object in itself with respective <code>door</code> and <code>hiding</code> properties. Accessing these properties are easy enough via dot notation.
      </p>
      <pre><code class="lang-javascript">
  arr.forEach(<span class="hljs-literal">element</span> = {
    let <span class="hljs-literal">door</span> = <span class="hljs-literal">element.door</span> <span class="hljs-meta">// 1, 2, 3</span>
    let <span class="hljs-literal">hiding</span> = <span class="hljs-literal">element.hiding</span> <span class="hljs-meta">// Shaggy, Scooby, Velma</span>
  })
      </code></pre>
      <p>
        From here, the original problem becomes easier.  See the problem description below:
      </p>
      <blockquote>
        <p>This function will require you to <code>find</code> the door number that Scooby is hiding behind</p>
      </blockquote>
      <p>
        A note however that the problem asks us to use the <code>find</code> method. Otherwise, the problem is now very straightforward to solve because we have a complete mental model of the data structure with the help of <code>console.log</code> ðŸ¥³
      </p>

      <h2>Problem solving techniques</h2>
      <h3>Pseudocode</h3>
      <p>
        I love writing pseudo code! I see it as an opportunity to <em>internalize the problem prior to writing code</em>! I showed one of my colleagues a function I was writing for a web-server and the function had 32 lines, with 8 lines consisting of actual code. That&#39;s 75% comments 25% code ðŸ¤¯
      </p>

      <h3>Rubber Duck Method</h3>
      <p>
        Well it doesn&#39;t have to be an actual duck. I talk to myself when I code! Especially if I&#39;m trying to learn something new. I believe that <em>vocalization is a very powerful facilitator to learning</em>.
      </p>

      <h3>Reading Error Messages</h3>
      <p>
        The first one is always a heart-sinker - <em>but they leave breadcrumbs to tell you where to start</em>. If you chop and change some code and the error message changes, don&#39;t fret! It means you&#39;re closer to solving the problem. just make sure that you are changing code with focused intent - <strong>NEVER hack and slash</strong>.
      </p>

      <h3>Logging</h3>
      <p>
        Logging is a tried and true method. They basically tell you the state (values of your variables) of your program where ever you log! And if your program terminates early, logging allows you to pin point the exact location in the program where your code stopped working. 
      </p>

      <h3>Googling</h3>
      <p>
        Anyone can google, but <em>it takes skill to google the right thing</em>. Keywords are vital to pruning hours of searching to mere moments. Without google, none of us can write reasonably large programs. Our minds are too small to retain all of this information - and we shouldn&#39;t try too! The idea is to copy and paste error messages to google for direction ðŸ˜‚
      </p>

      <h3>Support from peers</h3>
      <p>
        Speaking from past experience - pervious course - I would approach people ahead of me. We would have Zoom study sessions to share insights about difficult concepts and exams. 
      </p>
      <p>
        Not only do you get a live human grounding complex concepts for you, but you get real-time feedback should you choose to test your own understanding against your peers! <em>So throw away your ego and stand on the shoulders of giants</em>.
      </p>

      <h3>Support from coaches</h3>
      <p>
        Speaking from past experience - pervious course - I would approach facilitators <em>last</em>. But when I do, I make sure that my questions are well-researched with evidence of due diligence.
      </p>

      <h3>Self-reflection</h3>
      <p>
        For me, I think this is crucial above anything else. I would write about my experiences with the previous assessment every time I passed an exam/interview/project. I would lay out what worked and what did not and determine how I can better improve. 
      </p>
      <p>
        Having something concrete and drawing up a plan for the next step is also crucial for self-reflection in the distant future to reflect on how much one has improved in both knowledge and proficiency.
      </p>      
    </main>
    <footer>
      Made by Jason Aricheta
      <a href="#">Get in touch!</a>
    </footer>
  </body>
</html>